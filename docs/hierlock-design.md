# User / Account / Resource 階層ロック 設計書（`hierlock`）

## 1. 目的

本設計は、MySQL(InnoDB) の**行ロック**を利用して、`User → Account → Resource` の 3 階層に対するロック取得を再現し、単体テストで「ブロックする／しない」「デッドロックが起きうる／回避できる」を検証できるようにすることを目的とします。

- 対象パッケージ: `hierlock`
- 主用途: ロック挙動の検証（テスト）

## 2. スコープ

### 2.1 対象

- 階層: User / Account(User 配下) / Resource(Account 配下)
- ロックの種類:
  - 上位階層: 共有ロック
  - 対象階層: 排他ロック
- MySQL 8.0 / InnoDB を前提

### 2.2 非対象（非ゴール）

- 分散ロック（プロセス間・DB 跨ぎの一意性保証など）
- フェアネスや優先度制御
- 任意の複数ターゲットを同時に扱う汎用のデッドロック完全回避
- 長時間稼働する業務向けロック管理（本実装はテスト／検証用途）

## 3. 仕様（ロック取得ルール）

ロック対象の**上位階層は共有ロック**、対象自身は**排他ロック**。

例: `Resource(u1/a1/r1)` をロックする場合

- `User(u1)` : 共有
- `Account(u1/a1)` : 共有
- `Resource(u1/a1/r1)` : 排他

競合時は NOWAIT を使わず、基本挙動は**待ち（ブロック）**とします。

## 4. 実装方式

### 4.1 ロック用テーブル

行ロック対象を固定するため、以下のテーブルを使用します。

- テーブル: `hier_lock_buckets`
- カラム:
  - `level TINYINT NOT NULL`
  - `bucket INT NOT NULL`
  - `PRIMARY KEY(level, bucket)`

本方式では「ロック対象行＝バケット行」を**固定空間**として扱い、運用で無限増加しないようにします。

- ロック取得時に DML（INSERT/UPDATE）を行わず、Tx 内では `SELECT ... FOR SHARE/UPDATE` のみを行う
- バケット行は事前にプロビジョニング（例: デプロイ時のマイグレーション）しておく

注意:

- バケット空間が $10^7$ で、User/Account/Resource を別レベルとして扱うため、最大で **$3\times 10^7$ 行**のテーブルになります（固定上限）。

### 4.1.1 整合性（確実にロックできるか）について

本方式ではランタイムで `INSERT` を行いません。
実際にロックを取得するのは、トランザクション内で実行する `SELECT ... FOR SHARE / FOR UPDATE` です。

この方式で保証できること:

- `Acquire` / `AcquireResources` が成功して返った時点で、対象（level,bucket）に対するロック（共有／排他）は取得できています

注意すべき点（運用前提）:

- `hier_lock_buckets` の行が欠けていると、`SELECT ... FOR ...` が `no rows` で失敗します。
  - 対策: 事前プロビジョニングを必須にする（= マイグレーションで全バケット行を作成）
- ロック競合が長引くと、MySQL 側の `innodb_lock_wait_timeout` や呼び出し側の `context` タイムアウトで失敗する可能性があります。
  - 「確実に取り切る」が必須なら、呼び出し側で十分長いタイムアウトを与える／失敗時にリトライする（特に `1213` deadlock や `1205` timeout）などの方針が必要です

### 4.2 ロックキー設計

ロック対象は「実 ID そのもの」ではなく、**ストライプ（ハッシュ → バケット）**で表現します。

- バケット空間: $10^7$（`0..9,999,999`）
- ハッシュ: FNV-1a（32bit）
- 目的: 実 ID が増え続けても、ロック対象（バケット）が固定上限になるようにする

ロック対象は `(level, bucket)` の組で表現します。

- `level`: User=0 / Account=1 / Resource=2
- `bucket`: `hash(prefix + IDs) mod 10^7`

注意（重要）:

- 別の実 ID が同じバケットに割り当たる「衝突」が起きると、**偽競合（本来独立でもブロック）**が発生します。
  - 整合性（ロックが効かない）は損なわれませんが、並行性が低下します。

### 4.3 MySQL ロック操作

`hier_lock_buckets` の対象行（`level`,`bucket`）に対し、以下の SQL を発行してロックします。

- 共有ロック: `SELECT bucket FROM hier_lock_buckets WHERE level = ? AND bucket = ? FOR SHARE`
- 排他ロック: `SELECT bucket FROM hier_lock_buckets WHERE level = ? AND bucket = ? FOR UPDATE`

### 4.4 トランザクション設計

- 1 回のロック取得は **1 トランザクション**として実行します
- トランザクション分離レベル: `READ COMMITTED`
- ロック保持期間: `LockHandle.Release()` が呼ばれるまで
  - 実装では `Rollback()` によりロックを解放します（ロック取得専用 Tx のため）

## 5. ロック取得アルゴリズム

### 5.1 単一ターゲット（`Acquire`）

入力: `level, userID, accountID, resourceID`

1. `level` に応じてロックキー列を作成
   - User: `[User]`
   - Account: `[User, Account]`
   - Resource: `[User, Account, Resource]`
2. トランザクション開始
3. **祖先 → 子孫の順**にロックを取得
   - 祖先キー: `FOR SHARE`
   - 最終（対象）キー: `FOR UPDATE`
4. 取得成功したら `LockHandle{tx}` を返す

ポイント:

- 祖先 → 子孫の順に固定することで、階層内の循環待ちを起こしにくくします。

### 5.2 複数 Resource（`AcquireResources`）

目的: 同一 `(userID, accountID)` 配下で複数 Resource をロックする際のデッドロック回避。

1. トランザクション開始
2. `User` / `Account` を `FOR SHARE` で取得
3. `resourceIDs` を辞書順ソートし、**必ず同じ順序**で `FOR UPDATE` を取得

ポイント:

- 複数リソースを異なる順序で取り合うとデッドロックが起きうるため、取得順序を統一します。

## 6. エラーハンドリング

- 入力バリデーション: 必須 ID が空の場合はエラー
- ロック取得中に失敗した場合は `Rollback()` してロックを解放
- デッドロックやロック待ちタイムアウトは環境により発生しうるため、テスト側で `1205/1213` を判定できるよう補助関数を用意

## 7. テスト設計

### 7.1 DB 接続

- 環境変数 `MYSQL_DSN` があればそれを使用
- 未指定なら `docker-compose.yml` のデフォルト（`127.0.0.1:3306` / `mgl_test`）を使用
- MySQL に接続できない場合は **テストを SKIP**（CI やローカル利便性のため）

### 7.2 テーブル準備

- `hier_lock_buckets` を `CREATE TABLE IF NOT EXISTS`
- `TRUNCATE` で初期化
- テストでは、使用する（level,bucket）行だけを少量 INSERT してから実行（`seedBuckets`）

### 7.3 「ブロックする／しない」の観測

NOWAIT を使わないため、競合判定は以下で観測します。

- T1 がロックを保持した状態で
- T2 の `Acquire` を goroutine で実行
- 短い観測窓（例: 25ms）で完了しなければ「ブロックしている」とみなす
- T1 解放後に T2 が完了することを確認

### 7.4 デッドロック検証

- 対照実験: 2 つの Tx が複数 Resource を**逆順**で取り合うケースを作り、`1213`（deadlock）または `1205`（timeout）が起きうることを観測
- 回避策: `AcquireResources` によりソート順取得を強制し、デッドロックしにくいことを確認

### 7.5 網羅生成マトリクス

`Level × IDパターン` の組み合わせを生成し、ペアごとに「後続取得がブロックするか」を検証します。

- 実行時間対策として `2×2×2` 程度に縮小（ユーザー 2 / アカウント 2 / リソース 2）

## 8. CI（GitHub Actions）

- Workflow: `.github/workflows/test.yml`
- `services.mysql` で MySQL 8.0 を起動（healthcheck 付き）
- `MYSQL_DSN` を設定して `go test -count=1 ./...` を実行

## 9. 参考

- 期待挙動のシナリオ集: `docs/hierlock-scenarios.md`

## 10. 運用: バケット行のプロビジョニング案

本方式は「ランタイムで INSERT しない」前提のため、`hier_lock_buckets` に必要な行を事前に用意します。
バケット空間 $10^7$ をフルに使う場合、level が 3 種類あるので最大 $3\times 10^7$ 行になります。

### 10.1 プロビジョニングの基本方針

- 推奨: **デプロイ/初期構築時のマイグレーションで一度だけ作成**
- アプリ実行中にバケットを増やす運用（INSERT）にすると、共有ロック同士の両立を崩す/余計な競合が入り得るため避ける

### 10.2 SQL 例（10,000,000 行を生成）

MySQL 8.0 では再帰 CTE は上限が小さく（既定 1000 など）、そのままだと $10^7$ を生成できません。
そこで「0〜9 の 10 行」を 7 回クロス結合し、7 桁の数を生成する方法を例示します。

注意:

- これは“例”です。実環境ではロック/ログ/レプリケーション負荷が大きいので、時間帯・分割投入・バッチサイズを調整してください。

```sql
-- 0..9 の10行
WITH digits AS (
  SELECT 0 AS d UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4
  UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9
),
nums AS (
  SELECT
    (d6.d * 1000000 + d5.d * 100000 + d4.d * 10000 + d3.d * 1000 + d2.d * 100 + d1.d * 10 + d0.d) AS n
  FROM digits d0
  CROSS JOIN digits d1
  CROSS JOIN digits d2
  CROSS JOIN digits d3
  CROSS JOIN digits d4
  CROSS JOIN digits d5
  CROSS JOIN digits d6
)
INSERT INTO hier_lock_buckets(level, bucket)
SELECT 0, n FROM nums;

INSERT INTO hier_lock_buckets(level, bucket)
SELECT 1, n FROM nums;

INSERT INTO hier_lock_buckets(level, bucket)
SELECT 2, n FROM nums;
```

分割投入したい場合は `WHERE n BETWEEN ... AND ...` でチャンク化してください。

### 10.3 期待する運用上のメリット

- テーブルの行数が上限固定になり、**肥大化対策（定期削除）が不要**
- ロック取得 Tx が DML を含まないため、ロック挙動が読みやすい（共有/排他の互換性が崩れにくい）

## 11. この設計の不安点（リスク/トレードオフ）

この方式は「ロックが効かない」を避けやすい一方で、運用・性能面のトレードオフがあります。

### 11.1 バケット衝突（偽競合）

- 別の実 ID が同じ `(level,bucket)` に落ちると、本来独立な操作でもブロックします。
- 整合性は保てますが、並行性が落ち、レイテンシが増える可能性があります。

### 11.2 ホットバケット

- 特定の ID 群が偶然同一バケットに偏ると、そのバケットがホットスポットになり得ます。
- 兆候: 特定操作だけ待ちが多い、特定 bucket で競合が集中する。

### 11.3 初期投入コスト（$3\times 10^7$ 行）

- ストレージ・インデックスサイズ・バッファプールへの影響、投入時間、binlog/レプリケーション負荷が大きくなり得ます。
- 対策: 初期構築時のみ実施、分割投入、レプリケーション設計（必要なら）を事前に検討。

### 11.4 協調ロック前提

- これは「同じ規約でロックを取りに来た処理」だけを制御します。
- Repository で `GetUserLock` 等を必ず通す運用なら問題になりにくいですが、抜け道（直接 UPDATE 等）があると“ロックが効かない”のと同じ結果になります。

## 12. 比較検討（案 A / 案 B / 案 C）

本リポジトリでは、階層ロックを「MySQL の行ロックで再現し、単体テストで検証できる」ことを第一にしつつ、
実運用の観点での懸念（事前 INSERT 不要・テーブル肥大化）も踏まえて方式を比較しました。

ここでは代表的に以下の 3 案を整理します。

### 12.1 案 A: 実 ID ごとの固定ロック行（per-ID row）

概要:

- `hier_locks(lock_key PRIMARY KEY)` のようなテーブルに、`User(u1)`/`Account(u1/a1)`/`Resource(u1/a1/r1)` など「実 ID そのもの」をキーとして行を用意
- ロック取得は `SELECT ... FOR SHARE/UPDATE` で、その行をロック

長所:

- **衝突がない**ため、独立な ID 同士は原則ブロックしない（偽競合がほぼ無い）
- 挙動が直感的で、デバッグが容易

短所:

- 実 ID の増加に合わせて **行数が無制限に増える**（テーブル肥大化）
- 事前に行が必要（行が無ければ `no rows`）
  - “本番では事前 INSERT しない”という前提と相性が悪い

運用面の論点:

- **プロビジョニング**: 新しい ID が増えるたびに行が必要（バッチ作成 or アプリが作成）
- **肥大化対策**: 行が増え続けるので、保持期間・削除方針（いつ消して良いか）を決めないと運用が詰まりやすい
- **インデックス/ストレージ**: `lock_key` が長いとインデックスが重くなり、IO やバッファプールを圧迫しやすい
- **バックアップ/リストア**: 大量行になるほど dump/restore 時間が伸び、復旧時間（RTO）に影響しやすい
- **レプリケーション/binlog**: 行追加が多い運用だと binlog 量が増え、レプリケーション遅延の要因になり得る
- **監視**: テーブル行数やサイズ、増加率、ロック待ち（`performance_schema.data_locks` / `sys`）を継続監視したい

向いているケース:

- ロック対象 ID が少なく、テーブル増加が問題にならない
- 事前プロビジョニング/定期クリーンアップが許容できる

### 12.2 案 B: ロック取得時に行を作る（on-demand INSERT）

概要:

- 案 A の per-ID row を維持しつつ、ロック取得の直前に `INSERT IGNORE` 等で行を作成してから `SELECT ... FOR ...` を実行

長所:

- “事前 INSERT なし”でも動かしやすい（欠け行問題を回避しやすい）

短所（今回の重要論点）:

- ロック取得 Tx に **DML が混ざる**ため、負荷・競合・ロック挙動が複雑化しやすい
- 行作成のタイミングにより、共有ロック同士の両立を期待している場面でも
  INSERT 絡みの意図しないブロックが入り得る（テストで「ブロックしないはずがブロックした」などの不安定要因）
- テーブル肥大化は案 A と同様に残る（結局、実 ID 数だけ増える）

運用面の論点:

- **スループット**: ロック取得が高頻度だと `INSERT IGNORE` 等の DML がボトルネックになり得る
- **レプリケーション/binlog**: ロックのたびに書き込みが発生し、binlog 量/レプリケーション遅延のリスクが増える
- **障害時の挙動**: DB が重い時に DML がさらに重さを増幅させ、ロック待ち＋書き込み待ちが連鎖しやすい
- **整合性/競合の難しさ**: 「存在しない行を作ってからロックする」という流れは、競合条件が増えて調査が難しくなりやすい
- **クリーンアップ**: 行数無限増加の問題は残るため、案 A 同様に削除方針が必要

向いているケース:

- どうしても事前プロビジョニングできないが、テーブル肥大化を許容できる
- ロック挙動の複雑化を受け入れられる（または別の仕組みで整理できる）

### 12.3 案 C: ストライプ（バケット）方式（固定空間）

概要:

- 本設計で採用した方式
- 実 ID を直接キーにせず、`hash(...) mod 10^7` の **bucket** に落として `(level, bucket)` 行をロック
- ロック取得 Tx は **SELECT のみ**（ランタイム INSERT なし）

長所:

- テーブルの行数が **上限固定**（肥大化対策が不要）
- ランタイム DML が不要で、共有/排他の互換性の観測が安定しやすい
- デッドロック回避は「取得順序の統一」で設計に取り込みやすい

短所:

- **衝突（偽競合）**により並行性が下がり得る
- フルプロビジョニング時の初期投入コスト（最大 $3\times 10^7$ 行）が大きい

運用面の論点:

- **初期投入**: 大量 INSERT の実行計画（チャンク、実行時間帯、binlog/レプリケーション方針、障害時のリトライ）を事前に決める必要
- **ストレージ/バッファ**: 上限固定とはいえサイズは大きくなり得るため、ディスク/バッファプールの見積もりが必要
- **監視（偽競合）**: 実 ID の増加に伴い、特定 bucket がホットになっていないか（待ち時間/競合の偏り）を観測したい
- **容量の“静的コスト”**: 使っていない bucket も行として存在するため、少量データの段階では割高に見える
- **チューニング余地**: bucket 空間（$10^7$）は衝突率と初期投入コストのトレードオフなので、要件に応じて見直し余地がある

向いているケース:

- “事前 INSERT しない”という業務前提が強い
- テーブル肥大化を避けたい
- 多少の偽競合は許容できる（正しさ優先）

### 12.4 採用判断（なぜ案 C にしたか）

今回のゴール（単体テストでの挙動検証＋運用現実への適合）に対して、
以下が決定要因になりました。

- 案 A/案 B は、実 ID 増加に伴うテーブル肥大化を根本解決できない
- 案 B は、ロック取得中の DML がロック観測を不安定にし得る（共有ロックの両立期待と干渉しやすい）
- 案 C は、衝突というトレードオフはあるが、
  - ロック対象が固定上限で
  - ロック取得 Tx が SELECT だけになり
  - 「ロックが効かない」系の不安を減らしやすい

結論として、本リポジトリの目的（検証・再現性）と、
ユーザー要件（空間 $10^7$ まで、テーブル肥大化を避ける、事前 INSERT なし運用への不安）を両立しやすい案 C を採用しました。

### 11.5 タイムアウト/エラーは起こり得る

- デッドロックは取得順序統一で防げますが、待ち時間が長いと `context` / `innodb_lock_wait_timeout` で失敗する可能性は残ります。
- 許容するなら OK ですが、業務要件として必要ならリトライ方針（`1205`/`1213`）を上位で持つのが一般的です。
